<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kikimo</title>
    <link>https://coderatwork.cn/</link>
    <description>Recent content on kikimo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 03 Feb 2020 14:35:42 +0800</lastBuildDate>
    
	<atom:link href="https://coderatwork.cn/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ps 指令 hang 死原因分析（一）</title>
      <link>https://coderatwork.cn/posts/analysis-of-ps-hang-01/</link>
      <pubDate>Mon, 03 Feb 2020 14:35:42 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/analysis-of-ps-hang-01/</guid>
      <description>一台 cassandra 服务器出了问题， 登陆上去执行ps aux命令没有响应， ctrl + c也无法退出。 重新登陆机器执行ps aux又挂住没法操作了。 只能再登陆机器， 跑strace ps aux观察，又卡住了：
# strace ps aux stat(&amp;#34;/proc/180944&amp;#34;, {st_mode=S_IFDIR|0555, st_size=0, ...}) = 0 open(&amp;#34;/proc/180944/stat&amp;#34;, O_RDONLY) = 6 read(6, &amp;#34;180944 (ps) D 1 180804 31034 0 -&amp;#34;..., 2048) = 330 close(6) = 0 open(&amp;#34;/proc/180944/status&amp;#34;, O_RDONLY) = 6 read(6, &amp;#34;Name:\tps\nUmask:\t0022\nState:\tD (d&amp;#34;..., 2048) = 1205 close(6) = 0 open(&amp;#34;/proc/180944/cmdline&amp;#34;, O_RDONLY) = 6 read(6, &amp;#34;ps\0-ef\0&amp;#34;, 131072) = 7 read(6, &amp;#34;&amp;#34;, 131065) = 0 close(6) = 0 stat(&amp;#34;/etc/localtime&amp;#34;, {st_mode=S_IFREG|0644, st_size=388, .</description>
    </item>
    
    <item>
      <title>ICMP 和 ping</title>
      <link>https://coderatwork.cn/posts/icmp-and-ping/</link>
      <pubDate>Sat, 01 Feb 2020 14:55:06 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/icmp-and-ping/</guid>
      <description>ICMP(internet control management protocol) 是四层的协议。 根据 Understanding LINUX NETWORK INTERNALS Chapter 25 中的介绍，ICMP 的主要作用是交换控制信息：
 The Internet Control Message Protocol (ICMP) is a transport protocol used by Internet hosts to exchange control messages, notably error notifications and information requests.
 Linux 内核的协议栈中包含了 ICMP， 不过这个协议比较有意思， 它的实现是一半在内核态一半在用户态。 我们经常使用 ping 指令来测试某个节点是否在线， ping 指令用的便是 ICMP 协议， 它向目标机器发送 ICMP echo request 报文，并等待目标机器发回的 ICMP echo response 报文， 这些操作都是在用户态下完成的。 目标节点接收到 ICMP echo request 报文后会自动发送 ICMP echo response 报文， 基本上没人听说过 ping server 应用，因为接收报文和回应报文的操作是内核中的 ICMP 协议自动完成的。</description>
    </item>
    
    <item>
      <title>为什么 DNS 中应该避免 CNAME 记录和 MX 记录共存</title>
      <link>https://coderatwork.cn/posts/dns-cname-mx-record-conflict/</link>
      <pubDate>Fri, 31 Jan 2020 21:02:45 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/dns-cname-mx-record-conflict/</guid>
      <description>DNS 协议不允许 CNAME 记录和 MX 记录共存。 造成这种约束的主要原因在于：
 DNS 会对 CNAME 记录走递归解析 CNAME 记录的优先级高于 MX 记录  递归 DNS 服务器在查询某个常规域名记录（非 CNAME 记录）时， 如果在本地 cache 中已有该域名有对应的 CNAME 记录， 则会开始用该别名记录来重启查询， 这样 MX 记录会被 CNAME 别名记录的 MX 记录所覆盖。 这个过程，如果我们把 MX 记录替换成 A 记录理解起来也许就更容易了。 实际上，不只是 MX 记录，CNAME 记录和其他非 CNAME 记录都会造成冲突， 除了特殊的 DNSSEC 记录。
以下摘自 wiki CNAME record
 CNAME records are handled specially in the domain name system, and have several restrictions on their use.</description>
    </item>
    
  </channel>
</rss>