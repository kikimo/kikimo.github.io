<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kikimo</title>
    <link>https://coderatwork.cn/</link>
    <description>Recent content on kikimo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 22 Feb 2020 20:23:31 +0800</lastBuildDate>
    
	<atom:link href="https://coderatwork.cn/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Ansible vs Shell Script</title>
      <link>https://coderatwork.cn/posts/ansible-vs-shell-script/</link>
      <pubDate>Sat, 22 Feb 2020 20:23:31 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/ansible-vs-shell-script/</guid>
      <description>ansible 可以通过 playbook 用来完成节点的配置管理工作，如：基建部署、软件安装、服务管理等。 如果只是从完成的任务上看， ansible 的配置管理功能和 shell 脚本似乎是一样的， 既然如此，为什么还要花时间去部署、学习 ansible 呢？ 和 shell 脚本相比 ansible 有什么独特的优势？
1. 声明式 vs 指令式 ansible 内置了大量功能模块， 这些模块大部分是声明式（Declarative）的。 声明式的特点是你告诉 ansible 你想要的是一个什么样的结果， ansible 来帮你达成这个目标。 和声明式相对应的是命令式（imperative）, shell 脚本代码就是命令式的。 以文件的操作为例， 假设我们要创建一个目录， 使用 shell 指令的操作是：
$ mkdir /path/to/file 用 ansible 则是：
file: path: /path/to/file state: directory 乍看 ansible 这个操作跟 shell 指令也没什么区别，甚至更麻烦。 然而，我们这里用到的 ansiblefile模块可不止能用来创建文件， 你只要把 state 值设置为file它就能给你创建文件， 设置为absent时，ansible 就会帮你删除文件； 当我们创建多级目录的文件时， 如果忘了给mkdir指令加-p参数， 脚本可能就执行失败了。 使用 ansible 就不再需要关注如此细节的问题， 对文件的操作统一转化为对目标文件状态的描述， 只要设置好目标文件的状态 ansible 就会自动帮你达成这个目标。</description>
    </item>
    
    <item>
      <title>利用 ansible 部署 zookeeper 集群</title>
      <link>https://coderatwork.cn/posts/deploy-zookeeper-with-ansible/</link>
      <pubDate>Sat, 22 Feb 2020 19:30:32 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/deploy-zookeeper-with-ansible/</guid>
      <description>本文介绍如何利用 ansible 部署 zookeeper 集群。 zookeeper 的部署可以分为以下几个步骤：
 在部署节点创建部署目录 上传并解压 zookeeper 应用包 初始化 zookeeper 配置文件 启动 zookeeper 服务  步骤 1-3 可用 ansible task 来实现， 最后一个步骤使用 handler 来实现， 利用 handler 的好处在于： 只有步骤 1-3 中对节点配置做了变更后才会触发 zookeeper 重启。
需要创建的部署目录有：
 /opt/infra, 这个目录作为 zookeeper 的安装目录 /tmp/zookeeper, 这个目录作为 zookeeper 的 data 目录  tasks: - name: Create zookeeper installation directory file: path: &amp;#34;{{item}}&amp;#34; state: directory notify: Restart zookeeper service with_items: - /opt/infra - /tmp/zookeeper 这里使用了with_items迭代创建目录, 如果文件是第一次创建notify指令会调用Restart zookeeper service handler来重启 zookeeper 服务。</description>
    </item>
    
    <item>
      <title>Ansible Dynamic Inventory</title>
      <link>https://coderatwork.cn/posts/ansible-dynamic-inventory/</link>
      <pubDate>Sat, 22 Feb 2020 14:50:45 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/ansible-dynamic-inventory/</guid>
      <description>ansible 默认从静态 inventory 文件/etc/ansible/hosts读取节点信息。 在构建自动化运维系统时， 一般我们的系统会动态的添加或者删除节点的操作， 这个时候使用 ansible 的静态 inventory 文件存放节点信息就难以满足我们的需求。 所幸 ansible 提供了 dynamic inventory 机制，让我们可以通过脚本的形式来提供节点信息。 ansible 通过-i参数指定 inventory 脚本：
$ ansible all -i inventory.py --list-hosts hosts (3): 127.0.0.1 10.58.10.209 10.57.33.40 inventory.py就是我们编写的 dynamic inventory 脚本， 这个脚本需要提供两个命令行选项（可以理解为 dynamic inventory 需要满足的接口规范）：
$ ./inventory.py usage: inventory.py [-h] [--list] [--host HOST] optional arguments: -h, --help show this help message and exit --list Get all hosts. --host HOST Get host vars. --list选项让脚本按照节点的分组，输出所有的节点信息：
$ ./inventory.py --list { &amp;#34;local&amp;#34;: [ &amp;#34;127.</description>
    </item>
    
    <item>
      <title>ANSI 转义码(ANSI escape code)解析</title>
      <link>https://coderatwork.cn/posts/parsing-ansi-escape-code/</link>
      <pubDate>Tue, 11 Feb 2020 22:54:39 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/parsing-ansi-escape-code/</guid>
      <description>ANSI 转义序列是命令行终端下用来控制光标位置、字体颜色以及其他终端选项的一项 in-bind signaling 标准。
 ANSI escape sequences are a standard for in-band signaling to control the cursor location, color, and other options on video text terminals and terminal emulators.
  In telecommunications, in-band signaling is the sending of control information within the same band or channel used for data such as voice or video. This is in contrast to out-of-band signaling which is sent over a different channel, or even over a separate network.</description>
    </item>
    
    <item>
      <title>原码、反码与补码</title>
      <link>https://coderatwork.cn/posts/binary-form/</link>
      <pubDate>Wed, 05 Feb 2020 19:41:04 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/binary-form/</guid>
      <description>二进制数的表示形式有三种：原码、补码和反码。 任意形式的二进制数， 最高位（MSB）都表示符号位，0 表示正数，1 标致负数。 例如原码总：00000001b表示正一，10000001b表示负一。 任意形式的二进制数的正数表示法都一样，他们差别在于对负数的表示上，以-1为例：
 -1的原码的表示为10000001b -1的反码表示为11111110b，它是在原码的基础上，符号位不变，其余位取反 -1的补码表示为11111111b，它的计算方法是将-1的反码加一  反码的主要作用就是用来快速计算补码，而补码的意义在于统一正数的加减法操作：a - b可以直接用a + (b的补码)表示。
补码运算的原理 这个推导是错的
为什么补码能够用加法运算来替代减法运算？ 这主要是使用了同余的原理。 首先，对于某个负数，我们可以找出它的正数同余，例如：
-3=125 mod 128 根据同余的运算规则，有：
(5-3)=(5+125) mod 128 (5-3) mod 128 = 2 (5 + 125) mod 128 = 2 模为什么取 128？ 128 是为了方便的计算负数的同余，同时，它还和变量的字长有关。 我们看模为 128 时，可以如何计算负数的余数，首先：
-3 mod 128 = 128 - 3 所以问题可转化为如何快速计算 128 - 3，又：
3 + (-3[反码]) + 1 = 128 128 - 3 = -3[反码] + 1 -3[反码] + 1就是前面提到的负数补码的计算方法， 模取128可以方便我们快速的计算负数的补码。 模取128另外一个原因和变量的字长有关，如果变量是8位， 那么它的某就应该是128，如果是16为，那就应该是32768，也就是变量的 MSB。</description>
    </item>
    
    <item>
      <title>Linux 中的 wake_q_add() 函数</title>
      <link>https://coderatwork.cn/posts/linux-wake_q_add/</link>
      <pubDate>Tue, 04 Feb 2020 11:14:56 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/linux-wake_q_add/</guid>
      <description>wake_q_add()是 Linux 内代码中的一个函数， 它尝试将一个系统进程放置到等待唤醒的队列中：
static bool __wake_q_add(struct wake_q_head *head, struct task_struct *task) { struct wake_q_node *node = &amp;amp;task-&amp;gt;wake_q; /* * Atomically grab the task, if -&amp;gt;wake_q is !nil already it means * its already queued (either by us or someone else) and will get the * wakeup due to that. * * In order to ensure that a pending wakeup will observe our pending * state, even in the failed case, an explicit smp_mb() must be used.</description>
    </item>
    
    <item>
      <title>GCC 内联汇编</title>
      <link>https://coderatwork.cn/posts/gcc-inline-asm/</link>
      <pubDate>Mon, 03 Feb 2020 19:55:21 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/gcc-inline-asm/</guid>
      <description>GCC 支持内联汇编， 格式如下：
asm ( assembler template : output operands (optional) : input operands (optional) : list of clobbered registers (optional) ); asm 又可以写作 __asm__, __asm__主要用来避免命名冲突。 assembler template 就是内联的汇编代码， output operands, input operands, list of clobbered registers分别指代 输入操作数，输入操作数，修饰寄存器列表。 参数的顺序从左到右使用数字序号来引用， 例如%0表示第一个参数。 以下是几个 GCC 内联汇编的例子：
1. 内存操作数(Memory operand constraint(m)) __asm__(&amp;#34;sidt %0\n&amp;#34; : :&amp;#34;m&amp;#34;(loc)); 以上代码的作用等同于*loc = idt（idt 表示中断向量表）, &amp;quot;m&amp;quot;表示操作数位于内存中， 其中%0表示第一个参数也就是loc。
2. 参数序号引用(Matching(Digit) constraints) __asm__(&amp;#34;incl %0&amp;#34; :&amp;#34;=a&amp;#34;(var):&amp;#34;0&amp;#34;(var)); 在这个例子中var既用作输入参数由用作输出参数， =a表示使用eax寄存器来存放变量var， =是修饰符，表示输出变量， 它告诉 GCC 这个变量的值会被覆盖。 &amp;ldquo;0&amp;quot;表示使用和第一个参数一样的存储来作为输出来源， 在这里就是eax寄存器。 这段代码展开后等价于：</description>
    </item>
    
    <item>
      <title>ps 指令 hang 死原因分析（一）</title>
      <link>https://coderatwork.cn/posts/analysis-of-ps-hang-01/</link>
      <pubDate>Mon, 03 Feb 2020 14:35:42 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/analysis-of-ps-hang-01/</guid>
      <description>一台服务器出了问题， 登陆上去执行ps aux命令没有响应， ctrl+c也无法退出。 重新登陆机器执行ps aux又挂住没法操作了。 只能再登陆机器， 跑strace ps aux观察，又卡住了：
# strace ps aux stat(&amp;#34;/proc/180944&amp;#34;, {st_mode=S_IFDIR|0555, st_size=0, ...}) = 0 open(&amp;#34;/proc/180944/stat&amp;#34;, O_RDONLY) = 6 read(6, &amp;#34;180944 (ps) D 1 180804 31034 0 -&amp;#34;..., 2048) = 330 close(6) = 0 open(&amp;#34;/proc/180944/status&amp;#34;, O_RDONLY) = 6 read(6, &amp;#34;Name:\tps\nUmask:\t0022\nState:\tD (d&amp;#34;..., 2048) = 1205 close(6) = 0 open(&amp;#34;/proc/180944/cmdline&amp;#34;, O_RDONLY) = 6 read(6, &amp;#34;ps\0-ef\0&amp;#34;, 131072) = 7 read(6, &amp;#34;&amp;#34;, 131065) = 0 close(6) = 0 stat(&amp;#34;/etc/localtime&amp;#34;, {st_mode=S_IFREG|0644, st_size=388, .</description>
    </item>
    
    <item>
      <title>Linux 中的 cmpxchg 宏</title>
      <link>https://coderatwork.cn/posts/linux-cmpxchg/</link>
      <pubDate>Sun, 02 Feb 2020 23:51:12 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/linux-cmpxchg/</guid>
      <description>cmpxchg 是 intel CPU 指令集中的一条指令， 这条指令经常用来实现原子锁， 我们来看 intel 文档中对这条指令的介绍：
 Compares the value in the AL, AX, EAX, or RAX register with the first operand (destination operand). If the two values are equal, the second operand (source operand) is loaded into the destination operand. Otherwise, the destination operand is loaded into the AL, AX, EAX or RAX register. RAX register is available only in 64-bit mode.
  This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</description>
    </item>
    
    <item>
      <title>ICMP 和 ping</title>
      <link>https://coderatwork.cn/posts/icmp-and-ping/</link>
      <pubDate>Sat, 01 Feb 2020 14:55:06 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/icmp-and-ping/</guid>
      <description>ICMP(internet control management protocol) 是四层的协议。 根据 Understanding LINUX NETWORK INTERNALS Chapter 25 中的介绍，ICMP 的主要作用是交换控制信息：
 The Internet Control Message Protocol (ICMP) is a transport protocol used by Internet hosts to exchange control messages, notably error notifications and information requests.
 Linux 内核的协议栈中包含了 ICMP， 不过这个协议比较有意思， 它的实现是一半在内核态一半在用户态。 我们经常使用 ping 指令来测试某个节点是否在线， ping 指令用的便是 ICMP 协议， 它向目标机器发送 ICMP echo request 报文，并等待目标机器发回的 ICMP echo response 报文， 这些操作都是在用户态下完成的。 目标节点接收到 ICMP echo request 报文后会自动发送 ICMP echo response 报文， 基本上没人听说过 ping server 应用，因为接收报文和回应报文的操作是内核中的 ICMP 协议自动完成的。</description>
    </item>
    
    <item>
      <title>为什么 DNS 中应该避免 CNAME 记录和 MX 记录共存</title>
      <link>https://coderatwork.cn/posts/dns-cname-mx-record-conflict/</link>
      <pubDate>Fri, 31 Jan 2020 21:02:45 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/dns-cname-mx-record-conflict/</guid>
      <description>DNS 协议不允许 CNAME 记录和 MX 记录共存。 造成这种约束的主要原因在于：
 DNS 会对 CNAME 记录走递归解析 CNAME 记录的优先级高于 MX 记录  递归 DNS 服务器在查询某个常规域名记录（非 CNAME 记录）时， 如果在本地 cache 中已有该域名有对应的 CNAME 记录， 则会开始用该别名记录来重启查询， 这样 MX 记录会被 CNAME 别名记录的 MX 记录所覆盖。 这个过程，如果我们把 MX 记录替换成 A 记录理解起来也许就更容易了。 实际上，不只是 MX 记录，CNAME 记录和其他非 CNAME 记录都会造成冲突， 除了特殊的 DNSSEC 记录。
以下摘自 wiki CNAME record
 CNAME records are handled specially in the domain name system, and have several restrictions on their use.</description>
    </item>
    
    <item>
      <title>cron 僵尸进程问题分析</title>
      <link>https://coderatwork.cn/posts/2018-04-08-analysis-of-a-zombie-process-problem/</link>
      <pubDate>Sat, 14 Apr 2018 21:57:46 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/2018-04-08-analysis-of-a-zombie-process-problem/</guid>
      <description>前段时间遇到一个比较诡异的问题, 一台服务器上突然出现了许多僵尸进程。 多数时候，这些僵尸进程出现在早上，大概到了下午又自动消失。 第二天又重复这样的情况。
查了下，这些僵尸进程的父进程都是一些挂在 cron 下的 bash 进程。
猜测是 cron 每天早上定时执行了某些任务留下了这些僵尸进程． 为什么会出现僵尸进程，以及，为什么这些僵尸进程到了下午又自己消失了？ 一开始希望直接从 cron 配置定位产生僵尸进程的任务， 检查发现这台机器上配置了相当数量的 cron 任务，逐一排查过去不现实，只能寻找其他思路．
僵尸进程意味着该进程已经执行结束， 但是父进程还没有调用 wait() 获取它的返回值， 从而导致已结束的进程进程处于僵尸(zombie)进程状态。 正常而言，一个进程结束后通常会在短暂的时间内处于僵尸进程状态． 长时间处于僵尸进程状态， 意味着父进程一直都没有调用 wait()， 所以我们首先检查下这些僵尸进程的父进程也就是 cron 进程在干什么。
可以看到 2584 这个僵尸进程的父进程 2582 处于睡眠状态。 strace 显示 2582 进程在等待在 read() 系统调用。 read()系统调用读取的文件描述符是 6， 利用 lsof 指令来查看这个文件描述符的详细信息。
可以看到这是个管道文件， 对应 inode 是 13865。 进程 2582 处于管道读的一端， 根据这个 inode 信息， 我们可以利用 lsof 进一步找出管道写的一端关联的进程。
根据 lsof 的输出，大致可以断定 2586 和 18826 这两个进程把标准输出和错误输入都重定向到管道 6 写的一端了。 经过检查发现 2586 进程执行的 sleep.</description>
    </item>
    
    <item>
      <title>tops 使用说明</title>
      <link>https://coderatwork.cn/posts/tdops/</link>
      <pubDate>Sat, 14 Apr 2018 21:57:46 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/tdops/</guid>
      <description>tdops 目前部署在线下测试环境机器 10.57.17.90 上，需要测试的同学可以吴文林申请访问权限。
1. tdops 是什么 tdops 是一套轻量级的自动化运维平台。 目前主要考虑为私有云场景下的系统运维工具，主要提供的功能为服务节点管理、软件包管理、服务管理，具体可分为以下几个方面：
 主机管理 软件包 集群管理 应用管理  系统的主要用例包括：
 节点录入 添加应用 添加集群 添加应用版本 发布应用 启动、关停、重启、检查服务状态  当前系统主要通过终端命令与用户交互，下面我们介绍系统的详细使用说明。
2. 查看帮助 tdops 通过提供一系列命令和子命令来完成相关操作，每个命令都直指 --help 选项，改选项会列出指令的使用说明：
$ tdops.py --help (mops) albania:magicops wenlin.wu$ ./tdops.py --help Usage: tdops.py [OPTIONS] COMMAND [ARGS]... 同盾运维部署工具 Options: --help Show this message and exit. Commands: app 应用管理 cluster 管理、部署集群 host 主机管理 pkg 软件包管理 我们可以看到 tdops 支持的一系列子命令，这些子命令本身也可以通过--help选线查看使用说明，而子命令也可能包含其他子命令：
$ tdops.py app --help Usage: tdops.</description>
    </item>
    
  </channel>
</rss>