<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on kikimo</title>
    <link>https://coderatwork.cn/posts/</link>
    <description>Recent content in Posts on kikimo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 11 Feb 2020 22:54:39 +0800</lastBuildDate>
    
	<atom:link href="https://coderatwork.cn/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ANSI 转义码(ANSI escape code)解析</title>
      <link>https://coderatwork.cn/posts/parsing-ansi-escape-code/</link>
      <pubDate>Tue, 11 Feb 2020 22:54:39 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/parsing-ansi-escape-code/</guid>
      <description>ANSI 转义序列是命令行终端下用来控制光标位置、字体颜色以及其他终端选项的一项 in-bind signaling 标准。
 ANSI escape sequences are a standard for in-band signaling to control the cursor location, color, and other options on video text terminals and terminal emulators.
  In telecommunications, in-band signaling is the sending of control information within the same band or channel used for data such as voice or video. This is in contrast to out-of-band signaling which is sent over a different channel, or even over a separate network.</description>
    </item>
    
    <item>
      <title>原码、反码与补码</title>
      <link>https://coderatwork.cn/posts/binary-form/</link>
      <pubDate>Wed, 05 Feb 2020 19:41:04 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/binary-form/</guid>
      <description>二进制数的表示形式有三种：原码、补码和反码。 任意形式的二进制数， 最高位（MSB）都表示符号位，0 表示正数，1 标致负数。 例如原码总：00000001b表示正一，10000001b表示负一。 任意形式的二进制数的正数表示法都一样，他们差别在于对负数的表示上，以-1为例：
 -1的原码的表示为10000001b -1的反码表示为11111110b，它是在原码的基础上，符号位不变，其余位取反 -1的补码表示为11111111b，它的计算方法是将-1的反码加一  反码的主要作用就是用来快速计算补码，而补码的意义在于统一正数的加减法操作：a - b可以直接用a + (b的补码)表示。
补码运算的原理 这个推导是错的
为什么补码能够用加法运算来替代减法运算？ 这主要是使用了同余的原理。 首先，对于某个负数，我们可以找出它的正数同余，例如：
-3=125 mod 128 根据同余的运算规则，有：
(5-3)=(5+125) mod 128 (5-3) mod 128 = 2 (5 + 125) mod 128 = 2 模为什么取 128？ 128 是为了方便的计算负数的同余，同时，它还和变量的字长有关。 我们看模为 128 时，可以如何计算负数的余数，首先：
-3 mod 128 = 128 - 3 所以问题可转化为如何快速计算 128 - 3，又：
3 + (-3[反码]) + 1 = 128 128 - 3 = -3[反码] + 1 -3[反码] + 1就是前面提到的负数补码的计算方法， 模取128可以方便我们快速的计算负数的补码。 模取128另外一个原因和变量的字长有关，如果变量是8位， 那么它的某就应该是128，如果是16为，那就应该是32768，也就是变量的 MSB。</description>
    </item>
    
    <item>
      <title>Linux 中的 wake_q_add() 函数</title>
      <link>https://coderatwork.cn/posts/linux-wake_q_add/</link>
      <pubDate>Tue, 04 Feb 2020 11:14:56 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/linux-wake_q_add/</guid>
      <description>wake_q_add()是 Linux 内代码中的一个函数， 它尝试将一个系统进程放置到等待唤醒的队列中：
static bool __wake_q_add(struct wake_q_head *head, struct task_struct *task) { struct wake_q_node *node = &amp;amp;task-&amp;gt;wake_q; /* * Atomically grab the task, if -&amp;gt;wake_q is !nil already it means * its already queued (either by us or someone else) and will get the * wakeup due to that. * * In order to ensure that a pending wakeup will observe our pending * state, even in the failed case, an explicit smp_mb() must be used.</description>
    </item>
    
    <item>
      <title>GCC 内联汇编</title>
      <link>https://coderatwork.cn/posts/gcc-inline-asm/</link>
      <pubDate>Mon, 03 Feb 2020 19:55:21 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/gcc-inline-asm/</guid>
      <description>本文主要根据Inline assembly for x86 in Linux一文的内容整理。
GCC 支持内联汇编， 格式如下：
asm ( assembler template : output operands (optional) : input operands (optional) : list of clobbered registers (optional) ); asm 又可以写作 __asm__, __asm__主要用来避免命名冲突。 assembler template 就是内联的汇编代码， output operands, input operands, list of clobbered registers分别指代 输入操作数，输入操作数，修饰寄存器列表。 参数的顺序从左到右使用数字序号来引用， 例如%0表示第一个参数。 以下是几个 GCC 内联汇编的例子：
1. 内存操作数(Memory operand constraint(m)) __asm__(&amp;#34;sidt %0\n&amp;#34; : :&amp;#34;m&amp;#34;(loc)); 以上代码的作用等同于*loc = idt（idt 表示中断向量表）, &amp;quot;m&amp;quot;表示操作数位于内存中， 其中%0表示第一个参数也就是loc。
2. 参数序号引用(Matching(Digit) constraints) __asm__(&amp;#34;incl %0&amp;#34; :&amp;#34;=a&amp;#34;(var):&amp;#34;0&amp;#34;(var)); 在这个例子中var既用作输入参数由用作输出参数， =a表示使用eax寄存器来存放变量var， =是修饰符，表示输出变量， 它告诉 GCC 这个变量的值会被覆盖。 &amp;ldquo;0&amp;quot;表示使用和第一个参数一样的存储来作为输出来源， 在这里就是eax寄存器。 这段代码展开后等价于：</description>
    </item>
    
    <item>
      <title>ps 指令 hang 死原因分析（一）</title>
      <link>https://coderatwork.cn/posts/analysis-of-ps-hang-01/</link>
      <pubDate>Mon, 03 Feb 2020 14:35:42 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/analysis-of-ps-hang-01/</guid>
      <description>一台服务器出了问题， 登陆上去执行ps aux命令没有响应， ctrl+c也无法退出。 重新登陆机器执行ps aux又挂住没法操作了。 只能再登陆机器， 跑strace ps aux观察，又卡住了：
# strace ps aux stat(&amp;#34;/proc/180944&amp;#34;, {st_mode=S_IFDIR|0555, st_size=0, ...}) = 0 open(&amp;#34;/proc/180944/stat&amp;#34;, O_RDONLY) = 6 read(6, &amp;#34;180944 (ps) D 1 180804 31034 0 -&amp;#34;..., 2048) = 330 close(6) = 0 open(&amp;#34;/proc/180944/status&amp;#34;, O_RDONLY) = 6 read(6, &amp;#34;Name:\tps\nUmask:\t0022\nState:\tD (d&amp;#34;..., 2048) = 1205 close(6) = 0 open(&amp;#34;/proc/180944/cmdline&amp;#34;, O_RDONLY) = 6 read(6, &amp;#34;ps\0-ef\0&amp;#34;, 131072) = 7 read(6, &amp;#34;&amp;#34;, 131065) = 0 close(6) = 0 stat(&amp;#34;/etc/localtime&amp;#34;, {st_mode=S_IFREG|0644, st_size=388, .</description>
    </item>
    
    <item>
      <title>Linux 中的 cmpxchg 宏</title>
      <link>https://coderatwork.cn/posts/linux-cmpxchg/</link>
      <pubDate>Sun, 02 Feb 2020 23:51:12 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/linux-cmpxchg/</guid>
      <description>cmpxchg 是 intel CPU 指令集中的一条指令， 这条指令经常用来实现原子锁， 我们来看 intel 文档中对这条指令的介绍：
 Compares the value in the AL, AX, EAX, or RAX register with the first operand (destination operand). If the two values are equal, the second operand (source operand) is loaded into the destination operand. Otherwise, the destination operand is loaded into the AL, AX, EAX or RAX register. RAX register is available only in 64-bit mode.
  This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</description>
    </item>
    
    <item>
      <title>ICMP 和 ping</title>
      <link>https://coderatwork.cn/posts/icmp-and-ping/</link>
      <pubDate>Sat, 01 Feb 2020 14:55:06 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/icmp-and-ping/</guid>
      <description>ICMP(internet control management protocol) 是四层的协议。 根据 Understanding LINUX NETWORK INTERNALS Chapter 25 中的介绍，ICMP 的主要作用是交换控制信息：
 The Internet Control Message Protocol (ICMP) is a transport protocol used by Internet hosts to exchange control messages, notably error notifications and information requests.
 Linux 内核的协议栈中包含了 ICMP， 不过这个协议比较有意思， 它的实现是一半在内核态一半在用户态。 我们经常使用 ping 指令来测试某个节点是否在线， ping 指令用的便是 ICMP 协议， 它向目标机器发送 ICMP echo request 报文，并等待目标机器发回的 ICMP echo response 报文， 这些操作都是在用户态下完成的。 目标节点接收到 ICMP echo request 报文后会自动发送 ICMP echo response 报文， 基本上没人听说过 ping server 应用，因为接收报文和回应报文的操作是内核中的 ICMP 协议自动完成的。</description>
    </item>
    
    <item>
      <title>为什么 DNS 中应该避免 CNAME 记录和 MX 记录共存</title>
      <link>https://coderatwork.cn/posts/dns-cname-mx-record-conflict/</link>
      <pubDate>Fri, 31 Jan 2020 21:02:45 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/dns-cname-mx-record-conflict/</guid>
      <description>DNS 协议不允许 CNAME 记录和 MX 记录共存。 造成这种约束的主要原因在于：
 DNS 会对 CNAME 记录走递归解析 CNAME 记录的优先级高于 MX 记录  递归 DNS 服务器在查询某个常规域名记录（非 CNAME 记录）时， 如果在本地 cache 中已有该域名有对应的 CNAME 记录， 则会开始用该别名记录来重启查询， 这样 MX 记录会被 CNAME 别名记录的 MX 记录所覆盖。 这个过程，如果我们把 MX 记录替换成 A 记录理解起来也许就更容易了。 实际上，不只是 MX 记录，CNAME 记录和其他非 CNAME 记录都会造成冲突， 除了特殊的 DNSSEC 记录。
以下摘自 wiki CNAME record
 CNAME records are handled specially in the domain name system, and have several restrictions on their use.</description>
    </item>
    
  </channel>
</rss>