<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on kikimo</title>
    <link>https://coderatwork.cn/posts/</link>
    <description>Recent content in Posts on kikimo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 22 Feb 2020 20:23:31 +0800</lastBuildDate>
    
	<atom:link href="https://coderatwork.cn/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Ansible vs Shell Script</title>
      <link>https://coderatwork.cn/posts/ansible-vs-shell-script/</link>
      <pubDate>Sat, 22 Feb 2020 20:23:31 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/ansible-vs-shell-script/</guid>
      <description>ansible 可以通过 playbook 用来完成各种机器配置管理工作： 如基建部署、软件安装、服务管理等。 如果只是从完成的任务上看， ansible 的配置管理功能和 shell 脚本似乎是一样的， 既然如此，那为什么还需要 ansible？nsible 跟 shell 脚本相比有什么优势吗？ 否则为什么还要花时间去部署、学习 ansible 的各项功能。
1. 声明式 vs 指令式 ansible 的模块大部分是声明式（Declarative）的。 声明式的特点是你在 playbook 中告诉 ansible 你想要的是一个什么样的结果， 至于如何达到这个目的，则有你调用的 ansible 来完成具体的工作。 为了更清晰的解释声明式的特点， 可以拿 k8s 中的 Deployment 来与之类比， 你可以在 k8s 在 Deployment 中定义你需要部署多少个容器实例， 至于如何去操作实现这一结果， 那是 k8s 自己会完成的工作。 和声明式相对应的是命令式（imperative）, shell 脚本代码就是命令式的。 以文件的操作为例， 假设我们要创建一个目录， 使用 shell 指令的操作是：
$ mkdir 用 ansible 则是：
file: path: &amp;#34;{{item}}&amp;#34; state: directory 什么，你觉得 ansible 这个操作跟 shell 脚本也没什么区别，甚至更麻烦？ 确实，第一眼看上去的确会让人有这样的感观。 然后，我们这里用到的 ansible file 可不止能用来创建文件， 你只要把 state 值设置为file它就能给你创建文件， 设置为absent，ansible 就会帮你上传文件， 到这里应该就能看清楚了， 我们只要设置期望的目标文件的状态，ansible 就会自动帮你达成目标。</description>
    </item>
    
    <item>
      <title>利用 ansible 部署 zookeeper 集群</title>
      <link>https://coderatwork.cn/posts/deploy-zookeeper-with-ansible/</link>
      <pubDate>Sat, 22 Feb 2020 19:30:32 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/deploy-zookeeper-with-ansible/</guid>
      <description>本文介绍如何利用 ansible 部署 zookeeper 集群。 zookeeper 的部署可以分为以下几个步骤：
 在部署节点创建部署目录 上传并解压 zookeeper 应用包 初始化 zookeeper 配置文件 启动 zookeeper 服务  步骤 1-3 可用 ansible task 来实现， 最后一个步骤使用 handler 来实现， 利用 handler 的好处在于： 只有步骤 1-3 中对节点配置做了变更后才会触发 zookeeper 重启。
需要创建的部署目录有：
 /opt/infra, 这个目录作为 zookeeper 的安装目录 /tmp/zookeeper, 这个目录作为 zookeeper 的 data 目录  tasks: - name: Create zookeeper installation directory file: path: &amp;#34;{{item}}&amp;#34; state: directory notify: Restart zookeeper service with_items: - /opt/infra - /tmp/zookeeper 这里使用了with_items迭代创建目录, 如果文件是第一次创建notify指令会调用Restart zookeeper service handler来重启 zookeeper 服务。</description>
    </item>
    
    <item>
      <title>Ansible Dynamic Inventory</title>
      <link>https://coderatwork.cn/posts/ansible-dynamic-inventory/</link>
      <pubDate>Sat, 22 Feb 2020 14:50:45 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/ansible-dynamic-inventory/</guid>
      <description>ansible 默认从静态 inventory 文件/etc/ansible/hosts读取节点信息。 在构建自动化运维系统时， 一般我们的系统会动态的添加或者删除节点的操作， 这个时候使用 ansible 的静态 inventory 文件存放节点信息就难以满足我们的需求。 所幸 ansible 提供了 dynamic inventory 机制，让我们可以通过脚本的形式来提供节点信息。 ansible 通过-i参数指定 inventory 脚本：
$ ansible all -i inventory.py --list-hosts hosts (3): 127.0.0.1 10.58.10.209 10.57.33.40 inventory.py就是我们编写的 dynamic inventory 脚本， 这个脚本需要提供两个命令行选项（可以理解为 dynamic inventory 需要满足的接口规范）：
$ ./inventory.py usage: inventory.py [-h] [--list] [--host HOST] optional arguments: -h, --help show this help message and exit --list Get all hosts. --host HOST Get host vars. --list选项让脚本按照节点的分组，输出所有的节点信息：
$ ./inventory.py --list { &amp;#34;local&amp;#34;: [ &amp;#34;127.</description>
    </item>
    
    <item>
      <title>ANSI 转义码(ANSI escape code)解析</title>
      <link>https://coderatwork.cn/posts/parsing-ansi-escape-code/</link>
      <pubDate>Tue, 11 Feb 2020 22:54:39 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/parsing-ansi-escape-code/</guid>
      <description>ANSI 转义序列是命令行终端下用来控制光标位置、字体颜色以及其他终端选项的一项 in-bind signaling 标准。
 ANSI escape sequences are a standard for in-band signaling to control the cursor location, color, and other options on video text terminals and terminal emulators.
  In telecommunications, in-band signaling is the sending of control information within the same band or channel used for data such as voice or video. This is in contrast to out-of-band signaling which is sent over a different channel, or even over a separate network.</description>
    </item>
    
    <item>
      <title>原码、反码与补码</title>
      <link>https://coderatwork.cn/posts/binary-form/</link>
      <pubDate>Wed, 05 Feb 2020 19:41:04 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/binary-form/</guid>
      <description>二进制数的表示形式有三种：原码、补码和反码。 任意形式的二进制数， 最高位（MSB）都表示符号位，0 表示正数，1 标致负数。 例如原码总：00000001b表示正一，10000001b表示负一。 任意形式的二进制数的正数表示法都一样，他们差别在于对负数的表示上，以-1为例：
 -1的原码的表示为10000001b -1的反码表示为11111110b，它是在原码的基础上，符号位不变，其余位取反 -1的补码表示为11111111b，它的计算方法是将-1的反码加一  反码的主要作用就是用来快速计算补码，而补码的意义在于统一正数的加减法操作：a - b可以直接用a + (b的补码)表示。
补码运算的原理 这个推导是错的
为什么补码能够用加法运算来替代减法运算？ 这主要是使用了同余的原理。 首先，对于某个负数，我们可以找出它的正数同余，例如：
-3=125 mod 128 根据同余的运算规则，有：
(5-3)=(5+125) mod 128 (5-3) mod 128 = 2 (5 + 125) mod 128 = 2 模为什么取 128？ 128 是为了方便的计算负数的同余，同时，它还和变量的字长有关。 我们看模为 128 时，可以如何计算负数的余数，首先：
-3 mod 128 = 128 - 3 所以问题可转化为如何快速计算 128 - 3，又：
3 + (-3[反码]) + 1 = 128 128 - 3 = -3[反码] + 1 -3[反码] + 1就是前面提到的负数补码的计算方法， 模取128可以方便我们快速的计算负数的补码。 模取128另外一个原因和变量的字长有关，如果变量是8位， 那么它的某就应该是128，如果是16为，那就应该是32768，也就是变量的 MSB。</description>
    </item>
    
    <item>
      <title>Linux 中的 wake_q_add() 函数</title>
      <link>https://coderatwork.cn/posts/linux-wake_q_add/</link>
      <pubDate>Tue, 04 Feb 2020 11:14:56 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/linux-wake_q_add/</guid>
      <description>wake_q_add()是 Linux 内代码中的一个函数， 它尝试将一个系统进程放置到等待唤醒的队列中：
static bool __wake_q_add(struct wake_q_head *head, struct task_struct *task) { struct wake_q_node *node = &amp;amp;task-&amp;gt;wake_q; /* * Atomically grab the task, if -&amp;gt;wake_q is !nil already it means * its already queued (either by us or someone else) and will get the * wakeup due to that. * * In order to ensure that a pending wakeup will observe our pending * state, even in the failed case, an explicit smp_mb() must be used.</description>
    </item>
    
    <item>
      <title>GCC 内联汇编</title>
      <link>https://coderatwork.cn/posts/gcc-inline-asm/</link>
      <pubDate>Mon, 03 Feb 2020 19:55:21 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/gcc-inline-asm/</guid>
      <description>GCC 支持内联汇编， 格式如下：
asm ( assembler template : output operands (optional) : input operands (optional) : list of clobbered registers (optional) ); asm 又可以写作 __asm__, __asm__主要用来避免命名冲突。 assembler template 就是内联的汇编代码， output operands, input operands, list of clobbered registers分别指代 输入操作数，输入操作数，修饰寄存器列表。 参数的顺序从左到右使用数字序号来引用， 例如%0表示第一个参数。 以下是几个 GCC 内联汇编的例子：
1. 内存操作数(Memory operand constraint(m)) __asm__(&amp;#34;sidt %0\n&amp;#34; : :&amp;#34;m&amp;#34;(loc)); 以上代码的作用等同于*loc = idt（idt 表示中断向量表）, &amp;quot;m&amp;quot;表示操作数位于内存中， 其中%0表示第一个参数也就是loc。
2. 参数序号引用(Matching(Digit) constraints) __asm__(&amp;#34;incl %0&amp;#34; :&amp;#34;=a&amp;#34;(var):&amp;#34;0&amp;#34;(var)); 在这个例子中var既用作输入参数由用作输出参数， =a表示使用eax寄存器来存放变量var， =是修饰符，表示输出变量， 它告诉 GCC 这个变量的值会被覆盖。 &amp;ldquo;0&amp;quot;表示使用和第一个参数一样的存储来作为输出来源， 在这里就是eax寄存器。 这段代码展开后等价于：</description>
    </item>
    
    <item>
      <title>ps 指令 hang 死原因分析（一）</title>
      <link>https://coderatwork.cn/posts/analysis-of-ps-hang-01/</link>
      <pubDate>Mon, 03 Feb 2020 14:35:42 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/analysis-of-ps-hang-01/</guid>
      <description>一台服务器出了问题， 登陆上去执行ps aux命令没有响应， ctrl+c也无法退出。 重新登陆机器执行ps aux又挂住没法操作了。 只能再登陆机器， 跑strace ps aux观察，又卡住了：
# strace ps aux stat(&amp;#34;/proc/180944&amp;#34;, {st_mode=S_IFDIR|0555, st_size=0, ...}) = 0 open(&amp;#34;/proc/180944/stat&amp;#34;, O_RDONLY) = 6 read(6, &amp;#34;180944 (ps) D 1 180804 31034 0 -&amp;#34;..., 2048) = 330 close(6) = 0 open(&amp;#34;/proc/180944/status&amp;#34;, O_RDONLY) = 6 read(6, &amp;#34;Name:\tps\nUmask:\t0022\nState:\tD (d&amp;#34;..., 2048) = 1205 close(6) = 0 open(&amp;#34;/proc/180944/cmdline&amp;#34;, O_RDONLY) = 6 read(6, &amp;#34;ps\0-ef\0&amp;#34;, 131072) = 7 read(6, &amp;#34;&amp;#34;, 131065) = 0 close(6) = 0 stat(&amp;#34;/etc/localtime&amp;#34;, {st_mode=S_IFREG|0644, st_size=388, .</description>
    </item>
    
    <item>
      <title>Linux 中的 cmpxchg 宏</title>
      <link>https://coderatwork.cn/posts/linux-cmpxchg/</link>
      <pubDate>Sun, 02 Feb 2020 23:51:12 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/linux-cmpxchg/</guid>
      <description>cmpxchg 是 intel CPU 指令集中的一条指令， 这条指令经常用来实现原子锁， 我们来看 intel 文档中对这条指令的介绍：
 Compares the value in the AL, AX, EAX, or RAX register with the first operand (destination operand). If the two values are equal, the second operand (source operand) is loaded into the destination operand. Otherwise, the destination operand is loaded into the AL, AX, EAX or RAX register. RAX register is available only in 64-bit mode.
  This instruction can be used with a LOCK prefix to allow the instruction to be executed atomically.</description>
    </item>
    
    <item>
      <title>ICMP 和 ping</title>
      <link>https://coderatwork.cn/posts/icmp-and-ping/</link>
      <pubDate>Sat, 01 Feb 2020 14:55:06 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/icmp-and-ping/</guid>
      <description>ICMP(internet control management protocol) 是四层的协议。 根据 Understanding LINUX NETWORK INTERNALS Chapter 25 中的介绍，ICMP 的主要作用是交换控制信息：
 The Internet Control Message Protocol (ICMP) is a transport protocol used by Internet hosts to exchange control messages, notably error notifications and information requests.
 Linux 内核的协议栈中包含了 ICMP， 不过这个协议比较有意思， 它的实现是一半在内核态一半在用户态。 我们经常使用 ping 指令来测试某个节点是否在线， ping 指令用的便是 ICMP 协议， 它向目标机器发送 ICMP echo request 报文，并等待目标机器发回的 ICMP echo response 报文， 这些操作都是在用户态下完成的。 目标节点接收到 ICMP echo request 报文后会自动发送 ICMP echo response 报文， 基本上没人听说过 ping server 应用，因为接收报文和回应报文的操作是内核中的 ICMP 协议自动完成的。</description>
    </item>
    
    <item>
      <title>为什么 DNS 中应该避免 CNAME 记录和 MX 记录共存</title>
      <link>https://coderatwork.cn/posts/dns-cname-mx-record-conflict/</link>
      <pubDate>Fri, 31 Jan 2020 21:02:45 +0800</pubDate>
      
      <guid>https://coderatwork.cn/posts/dns-cname-mx-record-conflict/</guid>
      <description>DNS 协议不允许 CNAME 记录和 MX 记录共存。 造成这种约束的主要原因在于：
 DNS 会对 CNAME 记录走递归解析 CNAME 记录的优先级高于 MX 记录  递归 DNS 服务器在查询某个常规域名记录（非 CNAME 记录）时， 如果在本地 cache 中已有该域名有对应的 CNAME 记录， 则会开始用该别名记录来重启查询， 这样 MX 记录会被 CNAME 别名记录的 MX 记录所覆盖。 这个过程，如果我们把 MX 记录替换成 A 记录理解起来也许就更容易了。 实际上，不只是 MX 记录，CNAME 记录和其他非 CNAME 记录都会造成冲突， 除了特殊的 DNSSEC 记录。
以下摘自 wiki CNAME record
 CNAME records are handled specially in the domain name system, and have several restrictions on their use.</description>
    </item>
    
  </channel>
</rss>