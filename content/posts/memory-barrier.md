---
title: "内存屏障笔记"
date: 2020-03-31T20:34:43+08:00
draft: true
---

ii在多核的并发的场景下，程序可能会产生预期外的指令重排现象，例如原本的代码是：

```C
a = 1 
b = 1
```

```C
a = 2;
b = 2;
```

实际执行效果可能会变成：

```C
while (b == 1) {
}
printf("%d", a)
```

防止这种指令重排的方法就是使用内存屏障。
这篇文章我们简要内存屏障的原理。
要理解内存屏障首先我们需要知道以上代码为什么会产生指令重排。
要理解指令重排的原因我们就需要理解现代多核计算机的设计架构。
（导致指令重排的原因有多重，如编译器重排等，我们这边只介绍和内存屏障有关的指令重排问题）。
现代多核 CPU 的设计中，每个 CPU 都有独立的缓存，
因此 CPU 之间需要保证缓存一致性，
目前这是通过缓存一致性协议 MESI 来完成的。

store buffer 和 invalidate queue 带来新的问题。
1. CPU 1 执行`a = 1;`发现 a 不在缓存中，于是在 store buffer 中设置`a = 1`，并发送 invalidate 消息
2. CPU 2 收到 invalidate 消息并存放到 invalidate queue 中
3. CPU 1 执行`b = 2`, b 在缓存中，直接修改缓存中的值
4. CPU 2 通过 MESI 协议或得 CPU 1 中变量 b 的值为 2
5. CPU 2 读取缓存中 a 变量的值，此时 a 的值尚未被 invalidate queue 中的数据刷新，`print("%d", a)`打印 1
6. CPU 2 刷新 invalidate queue 将 a 的值刷新为 2

